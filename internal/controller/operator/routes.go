//
// Copyright 2022 IBM Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package operator

import (
	"context"
	"fmt"
	"reflect"
	"strings"

	"github.com/opdev/subreconciler"
	routev1 "github.com/openshift/api/route/v1"
	corev1 "k8s.io/api/core/v1"
	k8sErrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/client-go/discovery"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	logf "sigs.k8s.io/controller-runtime/pkg/log"

	operatorv1alpha1 "github.com/IBM/ibm-iam-operator/api/operator/v1alpha1"
	"github.com/IBM/ibm-iam-operator/internal/controller/common"
)

const ClusterInfoConfigmapName = "ibmcloud-cluster-info"
const PlatformAuthServiceName = "platform-auth-service"
const PlatformIdentityManagementServiceName = "platform-identity-management"
const PlatformIdentityProviderServiceName = "platform-identity-provider"
const DefaultHTTPBackendServiceName = "default-http-backend"

// These are the annotations that must be set on all Routes generated by this Operator
var commonRouteAnnotations map[string]string = map[string]string{
	"haproxy.router.openshift.io/timeout":                               "180s",
	"haproxy.router.openshift.io/pod-concurrent-connections":            "200",
	"haproxy.router.openshift.io/rate-limit-connections":                "true",
	"haproxy.router.openshift.io/rate-limit-connections.concurrent-tcp": "200",
	"haproxy.router.openshift.io/rate-limit-connections.rate-tcp":       "200",
	"haproxy.router.openshift.io/rate-limit-connections.rate-http":      "200",
	"haproxy.router.openshift.io/hsts_header":                           "max-age=31536000;includeSubDomains",
}

type reconcileRouteFields struct {
	Name        string
	Annotations map[string]string
	RouteHost   string
	RoutePath   string
	RoutePort   int32
	ServiceName string
	TLS         *routev1.TLSConfig
}

func (r *AuthenticationReconciler) handleRoutes(ctx context.Context, req ctrl.Request) (result *ctrl.Result, err error) {
	log := logf.FromContext(ctx)
	handleRouteCtx := logf.IntoContext(ctx, log)

	log.Info("Ensure all Routes are present when supported on the cluster")
	if !common.ClusterHasRouteGroupVersion(&r.DiscoveryClient) {
		log.Info("The Route API resource is not supported by this cluster")
		return subreconciler.ContinueReconciling()
	}

	authCR := &operatorv1alpha1.Authentication{}
	if result, err = r.getLatestAuthentication(ctx, req, authCR); subreconciler.ShouldHaltOrRequeue(result, err) {
		return
	}

	return r.reconcileAllRoutes(handleRouteCtx, authCR)
}

// removeExistingRouteIfItHasDifferentHost produces a GenerateFn that removes
// the SecondaryReconciler's Route if that Route has an out-of-date .spec.host
// value.
func (r *AuthenticationReconciler) removeExistingRouteIfItHasDifferentHost() common.GenerateFn[*routev1.Route] {
	return func(s common.SecondaryReconciler, ctx context.Context, route *routev1.Route) (err error) {
		authCR := s.GetPrimary().(*operatorv1alpha1.Authentication)
		var routeHost string
		if result, suberr := r.getClusterAddress(authCR, &routeHost)(ctx); subreconciler.ShouldHaltOrRequeue(result, suberr) {
			return
		}
		objKey := types.NamespacedName{Name: s.GetName(), Namespace: s.GetNamespace()}
		if err = r.Get(ctx, objKey, route); k8sErrors.IsNotFound(err) {
			return nil
		} else if err != nil {
			return
		}

		if route.Name == IMCrtAuthRouteName && route.Spec.Host == strings.Join([]string{IMCrtAuthRoutePrefix, routeHost}, "-") {
			return nil
		} else if route.Spec.Host == routeHost {
			return nil
		}

		if err = r.Delete(ctx, route); k8sErrors.IsNotFound(err) {
			return nil
		} else if err != nil {
			err = fmt.Errorf("failed to delete Route with old .spec.host: %w", err)
		}
		return
	}
}

func (r *AuthenticationReconciler) reconcileAllRoutes(ctx context.Context, authCR *operatorv1alpha1.Authentication) (result *ctrl.Result, err error) {
	log := logf.FromContext(ctx)
	debugLog := log.V(1)
	debugCtx := logf.IntoContext(ctx, debugLog)

	allRoutesFields := &map[string]*reconcileRouteFields{}
	if result, err = r.getAllRoutesFields(authCR, allRoutesFields)(ctx); subreconciler.ShouldRequeue(result, err) {
		return
	}

	defer func() {
		for _, fields := range *allRoutesFields {
			fields.TLS = nil
		}
	}()
	allRouteReconcilers, err := r.getRouteSubreconcilers(authCR, allRoutesFields)
	if err != nil {
		log.Error(err, "Unexpected error occurred while preparing Route handling")
		return subreconciler.RequeueWithError(err)
	}

	if result, err = allRouteReconcilers.Reconcile(debugCtx); err != nil {
		log.Info("One or more errors were encountered while reconciling Routes; requeueing")
	} else if subreconciler.ShouldRequeue(result, err) {
		log.Info("One or more Routes were written to; requeueing")
	} else {
		log.Info("Routes already up-to-date")
	}
	return
}

// getCustomIngressSecret retrieves the TLS Secret that is named in
// `.spec.config.ingress.secret` on the Authentication CR. Returns an error if
// it is unable to do so.
func (r *AuthenticationReconciler) getCustomIngressSecret(ctx context.Context, authCR *operatorv1alpha1.Authentication, secret *corev1.Secret) (err error) {
	if !authCR.HasCustomIngressCertificate() {
		return
	}
	objKey := types.NamespacedName{Name: *authCR.Spec.Config.Ingress.Secret, Namespace: authCR.Namespace}
	if err = r.Get(ctx, objKey, secret); err != nil {
		return
	}
	return
}

func modifyRoute(s common.SecondaryReconciler, ctx context.Context, observed, generated *routev1.Route) (modified bool, err error) {
	// Preserve custom annotation settings observed in the cluster; skip changes to rewrite-target
	for annotation, value := range observed.Annotations {
		if annotation != "haproxy.router.openshift.io/rewrite-target" {
			generated.Annotations[annotation] = value
		} else if generated.Annotations[annotation] != value {
			// Log when a rewrite-target annotation change has been ignored
			//reqLogger.Info("Attempted change to \"haproxy.router.openshift.io/rewrite-target\" prevented", "value", value)
		}
	}

	if !IsRouteEqual(ctx, generated, observed) {
		observed.Name = generated.Name
		observed.Annotations = generated.Annotations
		observed.Spec = generated.Spec
		modified = true
	}
	return
}

func dropRouteTLS(_ common.SecondaryReconciler, ctx context.Context, observed, generated *routev1.Route) error {
	observed.Spec.TLS = nil
	generated.Spec.TLS = nil
	return nil
}

func (r *AuthenticationReconciler) getRouteSubreconcilers(authCR *operatorv1alpha1.Authentication, allFields *map[string]*reconcileRouteFields) (subRecs common.Subreconcilers, err error) {
	subRecs = common.Subreconcilers{
		r.removeExtraRoutes(authCR, allFields),
	}
	builders := []*common.SecondaryReconcilerBuilder[*routev1.Route]{}

	for _, fields := range *allFields {
		builders = append(builders, common.NewSecondaryReconcilerBuilder[*routev1.Route]().
			WithName(fields.Name).
			WithGenerateFns(r.removeExistingRouteIfItHasDifferentHost(),
				generateRouteObject(fields)).
			WithModifyFns(modifyRoute),
		)
	}

	for i := range builders {
		subRecs = append(subRecs, builders[i].
			WithNamespace(authCR.Namespace).
			WithOnFinishedFns(dropRouteTLS).
			WithPrimary(authCR).
			WithClient(r.Client).
			MustBuild())
	}

	subRecs = append(subRecs, r.updateCPConsoleCertificates(authCR))

	return
}

// updateCPConsoleCertificates updates the certificate-related fields on the
// cp-console Route when .spec.config.ingress.secret is set on the
// Authentication CR. Skips when this field is not configured or if the Zen
// front door has been enabled on the Authentication CR with
// .spec.config.zenFrontDoor set to true.
func (r *AuthenticationReconciler) updateCPConsoleCertificates(authCR *operatorv1alpha1.Authentication) common.SecondaryReconcilerFn {
	return common.SecondaryReconcilerFn(func(ctx context.Context) (result *ctrl.Result, err error) {
		log := logf.FromContext(ctx, "Route.Name", "cp-console", "Route.Namespace", authCR.Namespace)
		log.Info("Update certificates on UI Route if custom TLS configured")
		if authCR.Spec.Config.ZenFrontDoor {
			log.Info("UI is using the Zen front door; continuing")
			return subreconciler.ContinueReconciling()
		}

		cpConsoleRoute := &routev1.Route{}
		objKey := types.NamespacedName{Name: "cp-console", Namespace: authCR.Namespace}
		if err = r.Get(ctx, objKey, cpConsoleRoute); err != nil {
			log.Error(err, "Failed to get Route")
			return subreconciler.RequeueWithError(fmt.Errorf("unable to configure cp-console with custom TLS: %w", err))
		}
		defer func() {
			cpConsoleRoute.Spec.TLS = nil
		}()

		modified := false
		if !authCR.HasCustomIngressCertificate() {
			log.Info("Custom TLS has not been requested; ensure that related TLS spec is cleared")
			if cpConsoleRoute.Spec.TLS.Key != "" {
				cpConsoleRoute.Spec.TLS.Key = ""
				modified = true
			}
			if cpConsoleRoute.Spec.TLS.Certificate != "" {
				cpConsoleRoute.Spec.TLS.Certificate = ""
				modified = true
			}
			if cpConsoleRoute.Spec.TLS.CACertificate != "" {
				cpConsoleRoute.Spec.TLS.CACertificate = ""
				modified = true
			}
		} else {
			log.Info("Custom TLS has been requested; ensure that related TLS spec is set")
			secret := &corev1.Secret{}
			if err = r.getCustomIngressSecret(ctx, authCR, secret); err != nil {
				log.Error(err, "Failed to get Secret", "Secret.Name", authCR.Spec.Config.Ingress.Secret, "Secret.Namespace", authCR.Namespace)
				return subreconciler.RequeueWithError(fmt.Errorf("unable to configure cp-console with custom TLS: %w", err))
			}
			if cpConsoleRoute.Spec.TLS.Key != string(secret.Data["tls.key"]) {
				cpConsoleRoute.Spec.TLS.Key = string(secret.Data["tls.key"])
				modified = true
			}
			if cpConsoleRoute.Spec.TLS.Certificate != string(secret.Data["tls.crt"]) {
				cpConsoleRoute.Spec.TLS.Certificate = string(secret.Data["tls.crt"])
				modified = true
			}
			if cpConsoleRoute.Spec.TLS.CACertificate != string(secret.Data["ca.crt"]) {
				cpConsoleRoute.Spec.TLS.CACertificate = string(secret.Data["ca.crt"])
				modified = true
			}
			common.ScrubMap(secret.Data)
		}

		if !modified {
			log.Info("No modifications needed for UI Route; continuing")
			return subreconciler.ContinueReconciling()
		}

		log.Info("UI Route needs update on TLS spec")
		if err = r.Update(ctx, cpConsoleRoute); err != nil {
			log.Error(err, "Failed to update UI Route")
			return subreconciler.RequeueWithError(err)
		}
		log.Info("UI Route successfully updated with custom TLS; requeueing")
		return subreconciler.RequeueWithDelay(defaultLowerWait)
	})
}

// removeExtraRoutes produces a subreconciler that deletes any Route that is labeled as IM's and is not in the list of
// Routes that the Operator wants to exist.
func (r *AuthenticationReconciler) removeExtraRoutes(authCR *operatorv1alpha1.Authentication, allRoutesFields *map[string]*reconcileRouteFields) (fn common.SecondaryReconcilerFn) {
	return func(ctx context.Context) (result *ctrl.Result, err error) {
		log := logf.FromContext(ctx)
		routesList := &routev1.RouteList{}
		desiredRoutesNames := func(rrf *map[string]*reconcileRouteFields) []string {
			n := []string{}
			for _, fields := range *rrf {
				n = append(n, fields.Name)
			}
			return n
		}(allRoutesFields)

		err = r.List(ctx, routesList, client.InNamespace(authCR.Namespace), client.MatchingLabels{"app": "im"})
		changed := false
		for _, item := range routesList.Items {
			if !common.ContainsString(desiredRoutesNames, item.Name) {
				log.Info("Removing extra Route", "Name", item.Name)
				if err = r.Delete(ctx, &item); k8sErrors.IsNotFound(err) {
					log.Info("Route was not found; continuing", "Name", item.Name)
					err = nil
				} else if err != nil {
					log.Info("Failed to delete extra Route for unexpected reason", "reason", err.Error(), "Name", item.Name)
					return subreconciler.RequeueWithDelay(defaultLowerWait)
				}
				log.Info("Successfully deleted extra Route", "Name", item.Name)
				changed = true
			}
		}
		if changed {
			log.Info("Deleted all extra Routes; requeuing")
			return subreconciler.RequeueWithDelay(defaultLowerWait)
		}

		return
	}
}

func (r *AuthenticationReconciler) getCustomTLS(authCR *operatorv1alpha1.Authentication, secret *corev1.Secret) common.SecondaryReconcilerFn {
	return func(ctx context.Context) (result *ctrl.Result, err error) {
		if !authCR.HasCustomIngressCertificate() {
			return subreconciler.ContinueReconciling()
		}
		objKey := types.NamespacedName{Name: *authCR.Spec.Config.Ingress.Secret, Namespace: authCR.Namespace}
		if err = r.Get(ctx, objKey, secret); err != nil {
			return subreconciler.RequeueWithError(err)
		}
		return subreconciler.ContinueReconciling()
	}
}

func (r *AuthenticationReconciler) getAllRoutesFields(authCR *operatorv1alpha1.Authentication, allRoutesFields *map[string]*reconcileRouteFields) (fn subreconciler.Fn) {
	return func(ctx context.Context) (result *ctrl.Result, err error) {
		routeHost := ""
		wlpClientID := ""
		var (
			platformAuthCert               []byte
			platformIdentityManagementCert []byte
			platformIdentityProviderCert   []byte
		)
		customTLSSecret := &corev1.Secret{}

		subRec := common.NewLazySubreconcilers(
			r.getClusterAddress(authCR, &routeHost),
			r.getWlpClientID(authCR, &wlpClientID),
			r.getCertificateForService(PlatformAuthServiceName, authCR, &platformAuthCert),
			r.getCertificateForService(PlatformIdentityManagementServiceName, authCR, &platformIdentityManagementCert),
			r.getCertificateForService(PlatformIdentityProviderServiceName, authCR, &platformIdentityProviderCert),
			r.getCustomTLS(authCR, customTLSSecret),
		)

		if result, err = subRec.Reconcile(ctx); subreconciler.ShouldRequeue(result, err) {
			return
		}

		key := ""
		caCrt := ""
		crt := ""

		if customTLSSecret.Data != nil {
			key = string(customTLSSecret.Data["tls.key"])
			crt = string(customTLSSecret.Data["tls.crt"])
			caCrt = string(customTLSSecret.Data["ca.crt"])
		}

		*allRoutesFields = map[string]*reconcileRouteFields{
			"id-mgmt": {
				Annotations: map[string]string{
					"haproxy.router.openshift.io/rewrite-target": "/",
				},
				Name:        "id-mgmt",
				RouteHost:   routeHost,
				RoutePath:   "/idmgmt/",
				RoutePort:   4500,
				ServiceName: PlatformIdentityManagementServiceName,
				TLS: &routev1.TLSConfig{
					DestinationCACertificate:      string(platformIdentityManagementCert),
					Termination:                   routev1.TLSTerminationReencrypt,
					InsecureEdgeTerminationPolicy: routev1.InsecureEdgeTerminationPolicyRedirect,
					Key:                           key,
					Certificate:                   crt,
					CACertificate:                 caCrt,
				},
			},
			"platform-auth": {
				Annotations: map[string]string{
					"haproxy.router.openshift.io/rewrite-target": "/v1/auth/",
				},
				Name:        "platform-auth",
				RouteHost:   routeHost,
				RoutePath:   "/v1/auth/",
				RoutePort:   4300,
				ServiceName: PlatformIdentityProviderServiceName,
				TLS: &routev1.TLSConfig{
					DestinationCACertificate:      string(platformIdentityProviderCert),
					Termination:                   routev1.TLSTerminationReencrypt,
					InsecureEdgeTerminationPolicy: routev1.InsecureEdgeTerminationPolicyRedirect,
					Key:                           key,
					Certificate:                   crt,
					CACertificate:                 caCrt,
				},
			},
			"platform-id-provider": {
				Annotations: map[string]string{
					"haproxy.router.openshift.io/rewrite-target": "/",
				},
				Name:        "platform-id-provider",
				RouteHost:   routeHost,
				RoutePath:   "/idprovider/",
				RoutePort:   4300,
				ServiceName: PlatformIdentityProviderServiceName,
				TLS: &routev1.TLSConfig{
					DestinationCACertificate:      string(platformIdentityProviderCert),
					Termination:                   routev1.TLSTerminationReencrypt,
					InsecureEdgeTerminationPolicy: routev1.InsecureEdgeTerminationPolicyRedirect,
					Key:                           key,
					Certificate:                   crt,
					CACertificate:                 caCrt,
				},
			},
			"platform-login": {
				Annotations: map[string]string{
					"haproxy.router.openshift.io/rewrite-target": fmt.Sprintf("/v1/auth/authorize?client_id=%s&redirect_uri=https://%s/auth/liberty/callback&response_type=code&scope=openid+email+profile&orig=/login", wlpClientID, routeHost),
				},
				Name:        "platform-login",
				RouteHost:   routeHost,
				RoutePath:   "/login",
				RoutePort:   4300,
				ServiceName: PlatformIdentityProviderServiceName,
				TLS: &routev1.TLSConfig{
					DestinationCACertificate:      string(platformIdentityProviderCert),
					Termination:                   routev1.TLSTerminationReencrypt,
					InsecureEdgeTerminationPolicy: routev1.InsecureEdgeTerminationPolicyRedirect,
					Key:                           key,
					Certificate:                   crt,
					CACertificate:                 caCrt,
				},
			},
			"platform-oidc": {
				Annotations: map[string]string{
					"haproxy.router.openshift.io/balance": "source",
				},
				Name:        "platform-oidc",
				RouteHost:   routeHost,
				RoutePath:   "/oidc",
				RoutePort:   9443,
				ServiceName: PlatformAuthServiceName,
				TLS: &routev1.TLSConfig{
					DestinationCACertificate:      string(platformAuthCert),
					Termination:                   routev1.TLSTerminationReencrypt,
					InsecureEdgeTerminationPolicy: routev1.InsecureEdgeTerminationPolicyRedirect,
					Key:                           key,
					Certificate:                   crt,
					CACertificate:                 caCrt,
				},
			},
			"saml-ui-callback": {
				Annotations: map[string]string{
					"haproxy.router.openshift.io/balance": "source",
				},
				Name:        "saml-ui-callback",
				RouteHost:   routeHost,
				RoutePath:   "/ibm/saml20/defaultSP",
				RoutePort:   9443,
				ServiceName: PlatformAuthServiceName,
				TLS: &routev1.TLSConfig{
					DestinationCACertificate:      string(platformAuthCert),
					Termination:                   routev1.TLSTerminationReencrypt,
					InsecureEdgeTerminationPolicy: routev1.InsecureEdgeTerminationPolicyRedirect,
					Key:                           key,
					Certificate:                   crt,
					CACertificate:                 caCrt,
				},
			},
			"social-login-callback": {
				Annotations: map[string]string{
					"haproxy.router.openshift.io/balance":        "source",
					"haproxy.router.openshift.io/rewrite-target": "/ibm/api/social-login",
				},
				Name:        "social-login-callback",
				RouteHost:   routeHost,
				RoutePath:   "/ibm/api/social-login",
				RoutePort:   9443,
				ServiceName: PlatformAuthServiceName,
				TLS: &routev1.TLSConfig{
					DestinationCACertificate:      string(platformAuthCert),
					Termination:                   routev1.TLSTerminationReencrypt,
					InsecureEdgeTerminationPolicy: routev1.InsecureEdgeTerminationPolicyRedirect,
					Key:                           key,
					Certificate:                   crt,
					CACertificate:                 caCrt,
				},
			},
			"platform-id-auth": {
				Annotations: map[string]string{
					"haproxy.router.openshift.io/balance":        "source",
					"haproxy.router.openshift.io/rewrite-target": "/",
				},
				Name:        "platform-id-auth",
				RouteHost:   routeHost,
				RoutePath:   "/idauth",
				RoutePort:   9443,
				ServiceName: PlatformAuthServiceName,
				TLS: &routev1.TLSConfig{
					DestinationCACertificate:      string(platformAuthCert),
					Termination:                   routev1.TLSTerminationReencrypt,
					InsecureEdgeTerminationPolicy: routev1.InsecureEdgeTerminationPolicyRedirect,
					Key:                           key,
					Certificate:                   crt,
					CACertificate:                 caCrt,
				},
			},
			IMCrtAuthRouteName: {
				Annotations: map[string]string{
					"haproxy.router.openshift.io/balance": "source",
				},
				Name:        IMCrtAuthRouteName,
				RouteHost:   strings.Join([]string{IMCrtAuthRoutePrefix, routeHost}, "-"),
				RoutePort:   9443,
				ServiceName: PlatformAuthServiceName,
				TLS: &routev1.TLSConfig{
					Termination:                   routev1.TLSTerminationPassthrough,
					InsecureEdgeTerminationPolicy: routev1.InsecureEdgeTerminationPolicyRedirect,
				},
			},
		}

		for _, routeFields := range *allRoutesFields {
			for annotation, value := range commonRouteAnnotations {
				routeFields.Annotations[annotation] = value
			}
		}
		return
	}
}

func shouldUseCPDHost(authCR *operatorv1alpha1.Authentication, dc *discovery.DiscoveryClient) bool {
	return !authCR.HasCustomIngressHostname() && authCR.Spec.Config.ZenFrontDoor && common.ClusterHasZenExtensionGroupVersion(dc)
}

// Use DeepEqual to determine if 2 routes are equal.
// Check annotations and Spec.
// If there are any differences, return false. Otherwise, return true.
func IsRouteEqual(ctx context.Context, oldRoute, newRoute *routev1.Route) bool {
	log := logf.FromContext(ctx, "Route.Name", oldRoute.Name).V(1)

	if !reflect.DeepEqual(oldRoute.Name, newRoute.Name) {
		log.Info("Names not equal", "old", oldRoute.Name, "new", newRoute.Name)
		return false
	}

	if !reflect.DeepEqual(oldRoute.Annotations, newRoute.Annotations) {
		log.Info("Annotations not equal",
			"old", fmt.Sprintf("%v", oldRoute.Annotations),
			"new", fmt.Sprintf("%v", newRoute.Annotations))
		return false
	}

	if !reflect.DeepEqual(oldRoute.Spec, newRoute.Spec) {
		//ugly, but don't print the CA to the log
		var loggedValues []interface{}

		loggedValues = append(loggedValues, "oldHost", oldRoute.Spec.Host, "newHost", newRoute.Spec.Host)

		loggedValues = append(loggedValues, "oldPath", oldRoute.Spec.Path, "newHost", newRoute.Spec.Path)

		loggedValues = append(loggedValues, "oldWildcardPolicy", oldRoute.Spec.WildcardPolicy, "newWildcardPolicy", newRoute.Spec.WildcardPolicy)

		loggedValues = append(loggedValues, "oldPort")
		if oldRoute.Spec.Port != nil {
			loggedValues = append(loggedValues, fmt.Sprintf("%v", oldRoute.Spec.Port))
		} else {
			loggedValues = append(loggedValues, "unset")
		}
		loggedValues = append(loggedValues, "newPort")
		if oldRoute.Spec.Port != nil {
			loggedValues = append(loggedValues, fmt.Sprintf("%v", newRoute.Spec.Port))
		} else {
			loggedValues = append(loggedValues, "unset")
		}

		loggedValues = append(loggedValues, "oldToService", fmt.Sprintf("%v", oldRoute.Spec.To))
		loggedValues = append(loggedValues, "newToService", fmt.Sprintf("%v", newRoute.Spec.To))

		loggedValues = append(loggedValues, "old.tls.termination")
		if oldRoute.Spec.TLS != nil {
			loggedValues = append(loggedValues, oldRoute.Spec.TLS.Termination)
		} else {
			loggedValues = append(loggedValues, "unset")
		}
		loggedValues = append(loggedValues, "new.tls.termination")
		if newRoute.Spec.TLS != nil {
			loggedValues = append(loggedValues, newRoute.Spec.TLS.Termination)
		} else {
			loggedValues = append(loggedValues, "unset")
		}

		loggedValues = append(loggedValues, "old.tls.insecureEdgeTerminationPolicy")
		if oldRoute.Spec.TLS != nil {
			loggedValues = append(loggedValues, oldRoute.Spec.TLS.InsecureEdgeTerminationPolicy)
		} else {
			loggedValues = append(loggedValues, "unset")
		}
		loggedValues = append(loggedValues, "new.tls.insecureEdgeTerminationPolicy")
		if newRoute.Spec.TLS != nil {
			loggedValues = append(loggedValues, newRoute.Spec.TLS.InsecureEdgeTerminationPolicy)
		} else {
			loggedValues = append(loggedValues, "unset")
		}

		log.Info("Specs not equal", loggedValues...)
		return false
	}

	return true
}

func generateRouteObject(fields *reconcileRouteFields) common.GenerateFn[*routev1.Route] {
	return func(s common.SecondaryReconciler, ctx context.Context, route *routev1.Route) (err error) {
		log := logf.FromContext(ctx)
		weight := int32(100)

		commonLabel := map[string]string{"app": "im"}
		routeLabels := common.MergeMaps(nil, s.GetPrimary().GetLabels(), commonLabel, common.GetCommonLabels())

		*route = routev1.Route{
			TypeMeta: metav1.TypeMeta{
				Kind:       "Route",
				APIVersion: routev1.SchemeGroupVersion.String(),
			},
			ObjectMeta: metav1.ObjectMeta{
				Name:        s.GetName(),
				Namespace:   s.GetNamespace(),
				Annotations: fields.Annotations,
				Labels:      routeLabels,
			},
			Spec: routev1.RouteSpec{
				Host: fields.RouteHost,
				Path: fields.RoutePath,
				Port: &routev1.RoutePort{
					TargetPort: intstr.IntOrString{
						Type:   intstr.Int,
						IntVal: fields.RoutePort,
					},
				},
				TLS: fields.TLS,
				To: routev1.RouteTargetReference{
					Name:   fields.ServiceName,
					Kind:   "Service",
					Weight: &weight,
				},
				WildcardPolicy: routev1.WildcardPolicyNone,
			},
		}

		// Set Authentication instance as the owner and controller of the Route
		err = controllerutil.SetControllerReference(s.GetPrimary(), route, s.GetClient().Scheme())
		if err != nil {
			log.Info("Failed to set owner for Route")
		}
		return
	}
}

func (r *AuthenticationReconciler) getClusterAddress(authCR *operatorv1alpha1.Authentication, clusterAddress *string) (fn common.SecondaryReconcilerFn) {
	return func(ctx context.Context) (result *ctrl.Result, err error) {
		clusterInfoConfigMap := &corev1.ConfigMap{}

		clusterAddressFieldName := "cluster_address"
		if shouldUseCPDHost(authCR, &r.DiscoveryClient) {
			clusterAddressFieldName = "cluster_address_auth"
		}

		fns := []subreconciler.Fn{
			r.getClusterInfoConfigMap(authCR, clusterInfoConfigMap),
			r.verifyConfigMapHasCorrectOwnership(authCR, clusterInfoConfigMap),
			r.verifyConfigMapHasField(authCR, clusterAddressFieldName, clusterInfoConfigMap),
		}

		for _, fn := range fns {
			if result, err = fn(ctx); subreconciler.ShouldRequeue(result, err) {
				return
			}
		}

		*clusterAddress = clusterInfoConfigMap.Data[clusterAddressFieldName]

		return subreconciler.ContinueReconciling()
	}
}

func (r *AuthenticationReconciler) getClusterInfoConfigMap(authCR *operatorv1alpha1.Authentication, cm *corev1.ConfigMap) (fn subreconciler.Fn) {
	return func(ctx context.Context) (result *ctrl.Result, err error) {
		log := logf.FromContext(ctx).V(1)
		err = r.Get(ctx, types.NamespacedName{Name: ClusterInfoConfigmapName, Namespace: authCR.Namespace}, cm)
		if k8sErrors.IsNotFound(err) {
			log.Info("ConfigMap was not found", "ConfigMap.Name", ClusterInfoConfigmapName)
			return subreconciler.RequeueWithDelay(defaultLowerWait)
		} else if err != nil {
			log.Error(err, "Failed to get ConfigMap", "ConfigMap.Name", ClusterInfoConfigmapName)
			return subreconciler.RequeueWithError(err)
		}

		log.Info("ConfigMap found", "ConfigMap.Name", cm.Name)
		return subreconciler.ContinueReconciling()
	}
}

func (r *AuthenticationReconciler) verifyConfigMapHasCorrectOwnership(authCR *operatorv1alpha1.Authentication, cm *corev1.ConfigMap) (fn subreconciler.Fn) {
	return func(ctx context.Context) (result *ctrl.Result, err error) {
		log := logf.FromContext(ctx)
		if !common.IsOwnerOf(r.Client.Scheme(), authCR, cm) {
			log.Info("ConfigMap is not owned by this Authentication", "ConfigMap.Name", cm.Name)
			return subreconciler.RequeueWithDelay(defaultLowerWait)
		}

		return subreconciler.ContinueReconciling()
	}
}

func (r *AuthenticationReconciler) verifyConfigMapHasField(_ *operatorv1alpha1.Authentication, fieldName string, cm *corev1.ConfigMap) (fn subreconciler.Fn) {
	return func(_ context.Context) (result *ctrl.Result, err error) {
		if cm.Data == nil || len(cm.Data[fieldName]) == 0 {
			err = fmt.Errorf("field %q is not set in ConfigMap %s", fieldName, ClusterInfoConfigmapName)
			return subreconciler.RequeueWithError(err)
		}

		return subreconciler.ContinueReconciling()
	}
}

func (r *AuthenticationReconciler) ensureConfigMapHasEqualFields(_ *operatorv1alpha1.Authentication, fields map[string]string, cm *corev1.ConfigMap) (fn subreconciler.Fn) {
	return func(ctx context.Context) (result *ctrl.Result, err error) {
		log := logf.FromContext(ctx)
		changed := false
		if cm.Data == nil {
			cm.Data = fields
			changed = true
			goto update
		}
		for fieldName, desiredValue := range fields {
			if observedValue, ok := cm.Data[fieldName]; ok && observedValue == desiredValue {
				continue
			}
			cm.Data[fieldName] = desiredValue
			changed = true
		}
		if !changed {
			log.Info("No changes to ConfigMap data fields needed", "ConfigMap.Name", cm.Name)
			return subreconciler.ContinueReconciling()
		}
	update:
		if err = r.Update(ctx, cm); err != nil {
			log.Error(err, "Failed to update ConfigMap data fields", "ConfigMap.Name", cm.Name)
			return subreconciler.RequeueWithError(err)
		}
		log.Info("Updated ConfigMap data fields successfully", "ConfigMap.Name", cm.Name)
		return subreconciler.RequeueWithDelay(defaultLowerWait)
	}
}

func (r *AuthenticationReconciler) getWlpClientID(authCR *operatorv1alpha1.Authentication, wlpClientID *string) (fn common.SecondaryReconcilerFn) {
	return func(ctx context.Context) (result *ctrl.Result, err error) {
		log := logf.FromContext(ctx)

		PlatformOIDCCredentialsSecretName := "platform-oidc-credentials"
		secret := &corev1.Secret{}
		err = r.Get(ctx, types.NamespacedName{Name: PlatformOIDCCredentialsSecretName, Namespace: authCR.Namespace}, secret)

		if k8sErrors.IsNotFound(err) {
			log.Info("Secret was not found", "Secret.Name", PlatformOIDCCredentialsSecretName)
			return subreconciler.RequeueWithDelay(defaultLowerWait)
		} else if err != nil {
			log.Error(err, "Failed to get secret", "Secret.Name", PlatformOIDCCredentialsSecretName)
			return subreconciler.RequeueWithError(err)
		}

		*wlpClientID = string(secret.Data["WLP_CLIENT_ID"][:])

		return subreconciler.ContinueReconciling()
	}
}

// getCertificateForService uses the provided Service name to determine which Secret contains the matching certificate
// data and returns it.
func (r *AuthenticationReconciler) getCertificateForService(serviceName string, authCR *operatorv1alpha1.Authentication, certificate *[]byte) (fn common.SecondaryReconcilerFn) {
	return func(ctx context.Context) (result *ctrl.Result, err error) {
		log := logf.FromContext(ctx)
		secret := &corev1.Secret{}
		var secretName string
		switch serviceName {
		case PlatformAuthServiceName:
			secretName = "platform-auth-secret"
		case PlatformIdentityManagementServiceName:
			secretName = "platform-identity-management"
		case PlatformIdentityProviderServiceName:
			secretName = "identity-provider-secret"
		default:
			err = fmt.Errorf("the Service %q does not have a certificate secret managed by this controller", serviceName)
			return subreconciler.RequeueWithError(err)
		}
		err = r.Get(ctx, types.NamespacedName{Name: secretName, Namespace: authCR.Namespace}, secret)
		if k8sErrors.IsNotFound(err) {
			log.Info("unable to get Route destination certificate, Secret does exist. Requeue and try again", "Secret.Name", secretName)
			return subreconciler.RequeueWithDelay(defaultLowerWait)
		} else if err != nil {
			log.Error(err, "failed to get Route destination certificate", "secretName", secretName)
			subreconciler.RequeueWithError(err)
		}

		caCrt, ok := secret.Data["ca.crt"]
		if !ok || len(caCrt) == 0 {
			err = fmt.Errorf("found Secret %q, but \"ca.crt\" was empty", secretName)
			return subreconciler.RequeueWithError(err)
		}
		*certificate = append(*certificate, caCrt...)
		return subreconciler.ContinueReconciling()
	}
}
